# iOSFeed
TDD, Modularization, Proper design patterns
Breaking responsibilities into multiple protocols (Interface Segregation Principle) to achieve flexible, composable and modular components.
Combining Xcode projects into a workspace and embedding frameworks to compose modules into a running iOS app.
Testing component behavior with the Stub test-double
Creating a flexible and modular strategy for loading data from remote with fallback logic without altering the services or the clients (Open/Closed Principle).
Composing objects that share a common interface with the Composite Design Pattern
Isolating side-effects to create simple, testable, and composable operations (Command-Query Separation Principle).
Using the Decorator Design Pattern to intercept and inject side-effects in the system composition, supporting single-purpose, testable, and modular components.
Using the Decorator Design Pattern to extend the behavior of a component without altering it (Open/Closed Principle).
Subclassing and extending components to remove conditional logic resulting in clean, decoupled, maintainable, and testable components.
Validating acceptance criteria with Integration Tests.
Replacing UI Tests with significantly faster and thorough Integration Tests.
Simulating app launch and state transitions during tests
Testing methods that cannot be invoked
Rendering views without running the app
UITableViewCell reuse cycle
Vertical modular slicing by features to physically separate components in order to avoid crossing boundaries
Organizing the codebase into independent frameworks and projects
